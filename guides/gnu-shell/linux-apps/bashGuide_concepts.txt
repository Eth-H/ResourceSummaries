//This document explains how to use bash
//page 50
Terminology>
	data streams
		// stdin = input
		// stdout = output
	exit/return status
		//all commands return a exit/return status, where 0 is successful and other values match a specific error code, in a script the last command run determines the scripts exit status
		

Argument passing>
	In the linux kernel one word arguments are passed with -, multiple single letter arguments can be chained
	A word argument needs a -- prefix
	//BSD syntax uses no dashes before a parameter
Shortcuts>
	Up Arrow – Show the previous command
	Ctrl + R – Allows you to type a part of the command you're looking for and finds it
	Ctrl + Z – Stops the current command, resume with fg in the foreground or bg in the background
	Ctrl + C – Halts the current command, cancel the current operation and/or start with a fresh new line
	Ctrl + L – Clear the screen
	command | less – Allows the scrolling of the bash command window using Shift + Up Arrow and Shift + Down Arrow
	!! – Repeats the last command
	command  !$ – Repeats the last argument of the previous command
	Esc + . (a period) – Insert the last argument of the previous command on the fly, which enables you to edit it before executing the command
	Ctrl + A – Return to the start of the command you're typing
	Ctrl + E – Go to the end of the command you're typing
	Ctrl + U – Cut everything before the cursor to a special clipboard, erases the whole line
	Ctrl + K – Cut everything after the cursor to a special clipboard
	Ctrl + Y – Paste from the special clipboard that Ctrl + U and Ctrl + K save their data to
	Ctrl + T – Swap the two characters before the cursor (you can actually use this to transport a character from the left to the right, try it!)
	Ctrl + W – Delete the word / argument left of the cursor in the current line
	Ctrl + D – Log out of current session, similar to exit

syntax>
    using wildcards
        ls .*
        [fu]*
        *.*f*u
	Operators>
			
			//|, Passes the stdout of a previous command to the stdin of the next one
			//-, redirection from/to stdin or stdout
				//EG pipe to the end of a command
				bunzip2 -c linux-2.6.16.tar.bz2 | tar xvf -
		// \, escape, give characters their literal meaning
			echo "The book cost \$7.98."
			//special escaped characheters
				\n //newline, \r //return, \t //tab, \v //vertical tab, \b //backspace
				\a //alert
	
            //Use "" to use something in that exact way (escape its alt meaning), '' act as a stronger version, EG '' is needed to escape the escape character '\'  
                //EG to find an exact word
                    find -name "exactFileName"
            Line formatting>
                //Run two commands on a line,
                    echo "Hello"; echo "World"				
                //Write a command on two lines (escapes whitespace)
                    echo "Hello "\
                    "World"	
                //Run command in the background, freeing up terminal to run commands
                    echo "Hello" &			
				
		operators used mostly in scripting>
			//comma
				//link series of arithemtic equations (only the last one is returned)
					let "t2 = ((a = 9, 15 / 3))"
				//concatenate strings
					/{,usr/}bin/
			//null command
				:
			//!
				not 
			//?
				//in (())	construct can act as c-style trinary operator		
				//condition?result-if-true:result-if-false
					(( var0 = var1<98?9:21 ))
			//()
				//command group, acts as a subshell that cant be read by the rest of the script	
					(a=hello; echo $a)
				//declare array
					Array=(element1 element2 element3)
				//integer expansion, expand and evaluate contained integer expression
					(($a + $b))
				
			//{}
				//extended brace expansion
					echo {a..z} # a b c d e f g h i j k l m n o p q r s t u v w x y z
					echo {0..3} # 0 1 2 3
				//anonymous function, but with globally visible variables
					{ local a; a=123; }
					
	Path>
		//Run something in the current folder
			./programname
		//Run via path starting from the root folder 
        //extract filename from path
            basename [path]
        //extract last dir from path
            dirname [path]
		//tidle, ~, home direcotory
			//~+, current working direcotry (pwd, $PWD)
			//=~, previous working direcotry ($OLDPWD)

	//custom
		variableName=value variableName2 = value2
		$value, ${value}
		numbers="1 2 3"
		//remove variable value
			unset variableName
		//declare variable and perform arithemtic caluclation
			let "uninitialized += 5"
		
		
alias shortcut ="cmd"
		
//permissions	
    //user, group, other
    //read, write, exe
    //get info
        groups

    //change
        //who, u | g | o | a: user, same group, other, all users 
         //operator, + | - | =: add, remove, exact permissions
          //permissions, r: read, w: write, x: execute 
        chmod {} {} {}
        //or use numbers, num1=user, num2=group, num3=other, 1=x, 3=r, 4=w 
            chmod 755

//job control
    ctrl z
    //%[jobNum]: 
    bg {}?
    fg {}?
    cmd & 
    //list jobs
        jobs -l 
    //kill proc, %[job num]:, [job PID]:,
        kill {}
        //sure kill
        kill -KILL
    //show info about logged in users and their processes 
        w

//history
    history
    //specific cmd
    ![historyNumber]
    //last cmd
    !!
    //last cmd args, *: all args, ^: 1st arg, $: 2nd arg
    !{}

//env variables
    $PWD, $PATH, $USER, $HOME
    //output all env
        env
    //last commands exit status
		$?
    //current running script PPID, script name
			$$, $0

Scripting>
	//Tell system what compilier/interpretor to use
		//sha-bang  (#! is a two byte magic number) followed by path to the interpretor program for that script
			//EGs
			#!/bin/sh
			#!/bin/bash
			#!/usr/bin/perl
			#!/usr/bin/tcl
			#!/bin/sed -f
			#!/usr/awk -f
			//since the sha-bang is always run first, below causes a self-deleting script
				#!/bin/rm
	//use script
		//Make that text file an executable, can give more permissions if needed
			chmod +x myscript.sh
		//run it
			./myscript.sh
		//move to a directory listed in path for global use
			/usr/local/bin
			
	//script env variables
       $[envVar] , ${[envVar} //same as above
        $0=shell script name
        $1=arg0, $2=arg1, $3... = arg...
        $* //all args
        $# //num of args passed 
		
		//move value from one positional parameter to anouther	
			$1 <--- $2
	iteration>
		for item in items; do 
            [commandInvolvingItem, $item]; 
        done
		while true; do  [thing] [if statement to terminate]

	Decision>
        [test] [expression]
        //return 0 if expr true, 1 if false
        
        //test construct, compares args and returns 1/0 relative to
exit status
            \[ expr \]
                ! expr //oposite
                //-a: true if both true (&), -o: true if either true (|)
                    expr = expr1 

                //=, !=
                    str {} str1 
                //-eq: a=b, -ne: a!=b, -gt: a>b, -lt: a<b, -ge: a>=b
                    num {} num1 
 
                //-r: readable, -w: writeable, -x: executable, -f: is file, -d: is dir 
                    {} file 

        //extended test
            //[[ ... ]]  		
            //acts more like scripting languages
        //arithemetic constructs
			//(( ... ))
            //returns exit status relative to arithemtic espressions expand to a non-zero value (=0 ES=1, <0 >0 = ES=0) 
			//EGs
				(( 0 && 1 )) //$? = 1
				//return result directly with $ (without assigning a variable)
					echo $(( 7 + 7 ))
				//nest and assign variables half way through
					echo $(( myvar = 7 + $(( vartwo = 4 + 4 )) )
			//let ... assigns the result of an equation to a value, however the exit status acts similarly to (( ... )), returns exit status relative to result (=0 ES=1, <0 >0 ES=0)
				//EG
					let x=-1 ; echo x=$x \$?=$? // x=-1 $?=0
        //implement constructs
            //if else block
                if [exp]; then 
                    ...
                elif [exp]; then
                    ...
                else
                    ...
                fi
            //case
                case "var" in 
                'val')
                    ...;    
                    ;;   
                'val1')
                    ...;    
                    ;;   
                *)
                    ...;
                    ;;
                esac

    functions>
        functionName(){
            #print passed parameter
            echo $1
        }
        #function call
        functionName "parameter"
        #pass function as parameter, with its paramters
            function x()      { echo "x(): Passed $1 and $2";  }
            function around() { echo before; "$@"; echo after; }
            around x 1st 2nd
		
    //edit streams		
        //redirect stdout to file, >: overite, >>: append
            cmd {} file 
        //redirects stdout and stderr of cmd to filename
            command &>filename
        //redirects stdout of command to stderr		
            >&2	
         //redirect streams
            //cmd stdout to cmd stdin
                [cmdOne] | [cmdTwo]
        //inject cmd stdout into anouther cmds stdin
            cmd `cmd1`
            cmd $(cmd1)        
