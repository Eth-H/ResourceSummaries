//This document explains how to use bash
//page 50
Terminology>
	data streams
		// stdin = input
		// stdout = output
	exit/return status
		//all commands return a exit/return status, where 0 is successful and other values match a specific error code, in a script the last command run determines the scripts exit status
		

Argument passing>
	In the linux kernel one word arguments are passed with -, multiple single letter arguments can be chained
	A word argument needs a -- prefix
	//BSD syntax uses no dashes before a parameter
Shortcuts>
	Up Arrow – Show the previous command
	Ctrl + R – Allows you to type a part of the command you're looking for and finds it
	Ctrl + Z – Stops the current command, resume with fg in the foreground or bg in the background
	Ctrl + C – Halts the current command, cancel the current operation and/or start with a fresh new line
	Ctrl + L – Clear the screen
	command | less – Allows the scrolling of the bash command window using Shift + Up Arrow and Shift + Down Arrow
	!! – Repeats the last command
	command  !$ – Repeats the last argument of the previous command
	Esc + . (a period) – Insert the last argument of the previous command on the fly, which enables you to edit it before executing the command
	Ctrl + A – Return to the start of the command you're typing
	Ctrl + E – Go to the end of the command you're typing
	Ctrl + U – Cut everything before the cursor to a special clipboard, erases the whole line
	Ctrl + K – Cut everything after the cursor to a special clipboard
	Ctrl + Y – Paste from the special clipboard that Ctrl + U and Ctrl + K save their data to
	Ctrl + T – Swap the two characters before the cursor (you can actually use this to transport a character from the left to the right, try it!)
	Ctrl + W – Delete the word / argument left of the cursor in the current line
	Ctrl + D – Log out of current session, similar to exit

syntax>
	Operators>
		//Combine commands with pipe
			[commandOne] | [commandTwo]
			//Redirect output to a file, >: overwrite target entirely or create file, >>: Append output to file or create file
		//Use wildcard to auto fill things
			cat fileNa*
		//Use "" to use something in that exact way (escape its alt meaning), '' act as a stronger version, EG '' is needed to escape the escape character '\'  
			//EG to find an exact word
				find -name "exactFileName"
		//redirection operators
			//redirect ouput and overwrite if existing filename
				scriptname >filename
			//	//redirect ouput and append if existing filename
				scriptname >>filename
			//redirects both the stdout and the stderr of command to filename.
				command &>filename
				//EG redirect errors
					type bogus_command &>/dev/null
			//redirects stdout of command to stderr		
				>&2	
			//|, Passes the stdout of a previous command to the stdin of the next one
			//-, redirection from/to stdin or stdout
				//EG pipe to the end of a command
				bunzip2 -c linux-2.6.16.tar.bz2 | tar xvf -
		//tidle, ~, home direcotory
			//~+, current working direcotry (pwd, $PWD)
			//=~, previous working direcotry ($OLDPWD)
		// \, escape, give characters their literal meaning
			echo "The book cost \$7.98."
			//special escaped characheters
				\n //newline, \r //return, \t //tab, \v //vertical tab, \b //backspace
				\a //alert
		//!
			//negate a condition
				true //gives exit status 0
				! true //gives exit status 1
			//invoke history
				...
		
		Line formatting>
			//Run two commands on a line,
				echo "Hello"; echo "World"				
			//Write a command on two lines (escapes whitespace)
				echo "Hello "\
				"World"	
			//Run command in the background, freeing up terminal to run commands
				echo "Hello" &			
				
		operators used mostly in scripting>
			//comma
				//link series of arithemtic equations (only the last one is returned)
					let "t2 = ((a = 9, 15 / 3))"
				//concatenate strings
					/{,usr/}bin/
			//null command
				:
			//!
				not 
			//?
				//in (())	construct can act as c-style trinary operator		
				//condition?result-if-true:result-if-false
					(( var0 = var1<98?9:21 ))
			//()
				//command group, acts as a subshell that cant be read by the rest of the script	
					(a=hello; echo $a)
				//declare array
					Array=(element1 element2 element3)
				//integer expansion, expand and evaluate contained integer expression
					(($a + $b))
				
			//{}
				//extended brace expansion
					echo {a..z} # a b c d e f g h i j k l m n o p q r s t u v w x y z
					echo {0..3} # 0 1 2 3
				//anonymous function, but with globally visible variables
					{ local a; a=123; }
					
	Path>
		//Run something in the current folder
			./programname
		//Run via path starting from the root folder 
			/directory/programname
variables>
	//noteable present variables
		//home directory
			$HOME
		//last commands exit status
			$?
		//path
			$PATH
		//current running script PPID
			$$
		//script name
			$0
	//custom
		variableName=value variableName2 = value2
		$value, ${value}
		numbers="1 2 3"
		//remove variable value
			unset variableName
		//declare variable and perform arithemtic caluclation
			let "uninitialized += 5"
		//assign command result
			a=`ls -l`
			//or
			a=$(ls -l)
	
		
		
Decision>
	case "$key" in
		$'\x1b\x5b\x32\x7e') # Insert
		echo Insert Key
		;;
		$'\x1b\x5b\x33\x7e') # Delete
		echo Delete Key
		;;
functions>
	functionName(){
		#print passed parameter
		echo $1
	}
	#function call
	functionName "parameter"
	#pass function as parameter, with its paramters
		function x()      { echo "x(): Passed $1 and $2";  }
		function around() { echo before; "$@"; echo after; }
		around x 1st 2nd
	

Scripting>
	//Tell system what compilier/interpretor to use
		//sha-bang  (#! is a two byte magic number) followed by path to the interpretor program for that script
			//EGs
			#!/bin/sh
			#!/bin/bash
			#!/usr/bin/perl
			#!/usr/bin/tcl
			#!/bin/sed -f
			#!/usr/awk -f
			//since the sha-bang is always run first, below causes a self-deleting script
				#!/bin/rm
	//EG script
		#! /bin/bash
		echo "This is my first bash script..."
		cd ~/Desktop
		ls -halt
		touch somefile
		ls -halt
		echo "Pretty cool, right?"
	//use script
		//Make that text file an executable, can give more permissions if needed
			chmod +x myscript.sh
		//run it
			./myscript.sh
		//move to a directory listed in path for global use
			/usr/local/bin
			
		//Run script
			./myscript.sh
	//script params
		./scriptname 1 2 3 4 5 6 7 8 9 10
		#!/bin/sh
		MINPARAMS=10
		args=$#    # Number of args passed.
		lastarg=${!#}
		echo
			if [ -n "$1" ]
				then
					echo "Parameter #1 is $1"
			fi
			if [ -n "$args" ] # Parameters > $9 must be enclosed in {brackets}.
				then
					echo "Parameter #10 is ${10}"
			fi	
			
			if [ $# -lt "$MINPARAMS" ]
				then
					echo "This script needs at least $MINPARAMS command-line arguments!"
			fi
		//avoid errors if params aren't passed
			variable1_=$1_ # Rather than variable1=$1
			critical_argument01=$variable1_
			//or
			if [ -z $1 ]
				then
					exit $E_MISSING_POS_PARAM
			fi
		//move value from one positional parameter to anouther	
			$1 <--- $2
	Loops>
		for item in [criteria]; do [commandInvolvingItem, $Item]; done
		for i in 1 2 3 4 5 6 7 8 9 10; do; echo -n "$i "; done &
		while true; do  [thing] [if statement to terminate]
	Decision>
		//if/then constructs test if a commmands exit status is 0, so 0 = true and 1 = false
		//[], test, it considers arguments as comprison expressions/file tests, then it returns 0 or 1 relative to coparison exit status
		//[[ ... ]], extended test, acts more like scripting languages
		//arithemetic constructs
			//(( ... )), returns  exit status relative to arithemtic espressions expand to a non-zero value (=0 ES=1, <0 >0 = ES=0) 
			//EGs
				(( 0 && 1 )) //$? = 1
				//return result directly with $ (without assigning a variable)
					echo $(( 7 + 7 ))
				//nest and assign variables half way through
					echo $(( myvar = 7 + $(( vartwo = 4 + 4 )) )
			//let ... assigns the result of an equation to a value, however the exit status acts similarly to (( ... )), returns exit status relative to result (=0 ES=1, <0 >0 ES=0)
				//EG
					let x=-1 ; echo x=$x \$?=$? // x=-1 $?=0
			
		
		
		
		
