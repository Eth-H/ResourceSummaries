//Constuctors  
	//same name as class
	//can have two constuctors (one needs a different num of params)
	//auto generated if not produced 
	
	Public class MyClass {
	   
        private int num;
        private int width;
        private String theString;

        MyClass(int width, String theString) {
            //attribute not passed as a param, so not used by this classes new objects
            num = 100;
            //if passing parameter to class instance with a different name, no this.
prefex needed
            newWidth = width
            this.theString = theString            
            //declare new variable
            int gaya = yaya
        }
        //second constructor has different number of parameters
        MyClass(){
            num = 100;
        }
    }

    //If class isn't present in current package import it
    import [packagePath].ExternalClass
    Public class MyClass2 {
        //create external objects using the constructor
	    private ExternalClass externalObject1;
        private ExternalClass externalObject2;
	    MyClass2(){
            //if new instance variable is the same
            externalObject1 = new ExternalClass()
	        
	    }
        //declare object outside constructor
        public void method(){
            ExternalClass localVariableExternalObject = new ExternalClass()
        } 
	}
//condition/decision 
    if(cond){
    }else if(cond){
    }else{}

    //tentiray/conditional operator
    condition ? value1 : value2


 //loops
    loopMethod(stringList){
        double total = 0;
        //equal to i<=(stringList.length-1)
        for (int i = 0; i < stringList.length; i++) {
            total += stringList[i];
        }   
        //foreach version, use to iterate entire list
        for (String stringItem: stringList){
            System.out.println(stringItem)
        }
        stringList.forEach((stringItem) -> {
                System.out.println(stringItem);
        });
        //while, iterate some of the list
            int index = 0;
            while(index < files.size()) {
                String filename = files.get(index);
                System.out.println(filename);
                index++;
            }           
    }

   
//arrays
    //set/basic array for primative data types, cant grow more than initial
size
        public class ArrayClass(){
            public void static main(){  
            int arraySize = 8 
            //declare array variable, then create array and assign
            int[] intList = new int[arraySize]        
            //or
            String[] stringList = {"element0", "element2"}     
            numbers = new int[] { 
                3, 15, 4, 5
            }; 
            //accessArray
            //get last element
            system.out.println(stringList[stringList.length-1])                
            }
        }
        //iterate array 
            for(int i = 0; i < numbers.length; i++) {
                System.out.println(i + ": " + numbers[i]);
            }
           for(Iterator<Track> it = tracks.iterator(); it.hasNext(); ) {
                Track track = it.next();
                if(track.getArtist().equals(artist)) {
                    it.remove();
                }
            }
 
    //utility methods, generally apply to any array implementation
        list.size()
        list.get(index)
            list.indexOf(element)
        list.add(element)
            //insert at specific index, (after that index, doesnt replace)
            list.add(index, element)                
            //add all elements in a list (not as a nested list)
            list.addAll(list2); list.addAll(index, list2)
            list.set(index, element)
        list.remove(index); list.remove(element)
            list.removeAll(list2)
            list.removeRange(fromIndex, toIndex)
        list.clear()       
        list.isEmpty()
        list.clone()
        array.binarySearch(), array.fill(), array.sort()
        arrayList.toArray()
    //group objects
        //lists for obj (collections) 
            //using java.util.ArrayList
               import java.util.ArrayList;
                public class MusicOrganizer{
                    //If java >=7 can omit the class data type and get it automatically
                    private ArrayList<String> files;
                    public MusicOrganizer(){
                        files = new ArrayList<>();
                    }
                } 

            //iterate collections
                //use generic for, foreach, while loop
                    
                //iterator obj, java.util.Iterator (provides sequential obj access) 
                //remove objects from list while iterating 
                    Iterator<StudentLoan> it = loans.iterator();
                    while(it.hasNext()){
                        StudentLoan loan = it.next();
                        if(loan.getName.equals(targetName){
                        it.remove();
                    }        

        //linked list
            //vs ArrayList
                //faster, implements list and queue (ArrayList just list)
                //better for manipulating data
            import java.util.LinkedList
            LinkedList loansLl = new LinkedList();
            loansLl.add(loan);
    
        //Hash set
            //no duplicates  
        import java.util.HashSet;
        HashSet<String> mySet = new HashSet<>();

        //Hash maps 
            //contain pair of objects, key and value
            HashMap <String, String> contacts = new HashMap<>();
            contacts.put("Charles Nguyen", "(531) 9392 4587");
            String number = contacts.get("Lisa Jones");
            //hash map methods  
                //add
                hashMap.put(key, value);
                //get keys or values  
                hashMap.keySet()
                hashMap.values()
                hashMap.containsKey()
                hashMap.containsValue()
            //get keys that match a specific value
                for (String name: contactsList.keySet()){
                    if (searchNum.equals(contactsList.get(name))){
                        collectionName.add(name)
                    }
                }
        //store primative types in a collection
            //wrap Pt into obj,
            //type -> wrapper class: int -> Integer, float -> Float, char -> Character
            int i = 18; 
            Integer iwrap = new Integer(i);  
            int value = iwrap.intValue();
            //under the hood autoboxing and unboxing occurs
                private ArrayList<Integer> markList; 
                int firstMark = markList.remove(0);

//manipulating strings
    Object.toString();
    String.endsWith(suffix); String.startsWith(prefix);
    //remove trail and whitespace
    String.trim();
    String.toLowerCase(); String.toUpperCase();
    String.indexof(char, indexToStartAt);
    String.substring(beginIndex, endIndex)
    Sring.compareTo();
    String.length
    System.out.printf("The value of the float variable is " +
                      "%f, while the value of the integer " +
                      "variable is %d, and the string " +
                      "is %s", floatVar, intVar, stringVar);


//useful libraries
    //Scanner, take input 
        import java.util.Scanner
        Scanner in = new Scanner(System.in);
        String s = in.inputLine();
        int a = in.nextInt();
        float b = in.nextFloat();

    //Random
        import java.util.Random;
        Random rand = new Random();
        int num = rand.nextInt();
        int value = 1 + rand.nextInt(100);
        //random list index
        int index = rand.nextInt(list.size());
        //return random number within rage
        rand.nextInt((max - min) + 1) + min

    //Math 
        Math.max(x, y)
        Math.min(x, y)
        Math.sqrt(64);
        //convert to absolute var (+ve)
        Math.abs(-4.7);
        Math.random();



//further generic implimencations
    //anonymous obj
        Lot furtherLot = new Lot(…);
        lots.add(furtherLot); 
        //obj immediately used, so name is unecessary
        lots.add(new Lot(…)); 
    //chaining method calls, immediatey call method on returned obj
        lot.getHighestBid().getBidder() 

//documentation
    //parameterized classes
        //docs include provsion for param type, these types are placeholders 
        //EG ArrayList<E> -> .add(E e)
    //comments
        //class
            //class name, comment summary (purpose, function), version, authors', doc for cons and methods
            /**
            * description
            * @author
            * @version
            */
        //constructor, method
            //name, return type, param (names and types), summary for method,
    parameter and returned value
            /**
             * Read a line of text from standard input (the text
             * terminal), and return it as a set of words.
             *
             * @param  prompt  A prompt to print to screen.
             * @return A set of strings, where each String is
             *         one of the words typed by the user
             */
            public HashSet<String> getInput(String prompt) 

//encapsulation
    //Private elements are accessible only to objects of the same class.
    //info hiding
        //obj have different class instances -> increase level of indepedance

    //class vairables
        //owned by class and shared between class instances,
        //access via class name (className.variable)
        public static int anInt = 10;
    //constant
        final int SIZE = 10;
    //combine
        //constants good for public class variables
            public static final int BOILING_POINT = 100; 
    //class methods
        public static int getDaysThisMonth() 
        Calendar.getDaysThisMonth();
        //dis adv
            //cant access instance fields or call instance methods within their class

//Java data types
	//Primitive Data Types
		//unsigned and sign size differences
			//unsigned: -2^7 = -128, 2^7-1 = 127, signed: 2^7  = 255,
		//sizes
			2^15 = 65535, 2^31 = 4294967296, 2^63 = 2*9,223,372,036,854,775,807+1  
	 
		//byte
			//8 bit signed two's complement (TC) int, -2^7 to 2^7-1
			//save space in arrays
		//short, 16 bit signed TC int, 2^7
		//int, 32 bit signed TC int, 2^31
		//long, 64 bit signed TC, 2^63, Default value (DV) = 0L  	
float,single-precision 32-bit IEEE 754 floating point, DV = 0.0f 
double, double-precision 64-bit IEEE 754 floating point, DV = 0.0d  
		//boolean, 1 bit, DF = false
		//char, 16 bit unicode character, \u0000 to \uffff
		int decimal = 100; int octal = 0144; int hexa =  0x64;
        
        //null, indicates no object
        null
        
        //convert between 
            Integer.parseInt(string);
            Integer.toString(int);
            
            //double -> float -> long -> int -> short -> byte 
                //explicit (type casting)
                    double d; long l; short s; 
                    long l = (long)d 
                    int i = (int)d 
                    byte b = (byte)i 



