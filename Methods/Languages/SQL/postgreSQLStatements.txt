--Creating a table
	--Table example
		-- Table: public.customer_data
		-- DROP TABLE public.customer_data;

		-- Create sequence to attach to a character, EG can be used for the primary key
		CREATE SEQUENCE user_id_seq2;
		CREATE TABLE public.customer_data
		(
			--Integer type, cant be null, attach sequence
			tally integer NOT NULL DEFAULT nextval('user_id_seq2'::regclass),
			--Takes up to 32 char, COLLATE organises the text in the column,
			user_id character(32) COLLATE pg_catalog."default" NOT NULL,
			address text COLLATE pg_catalog."default",
			neutralised_b BOOL,
			fleas integer,
			--JSON notation
			ObjectInJSON json,
			other_behaviour text,
			--Date format 'YYYY-MM-DD'
			date_current date,
			--Can add all keys at the end, names constraints
			--Apply primary key constraint
			CONSTRAINT customerdata_pk PRIMARY KEY (user_id)
			--Add foriegn key restraint to own column (generally foriegn key child shouldnt be a primary key (but the parent normally is))
			CONSTRAINT users_fkey FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
		)
		WITH (
			OIDS = FALSE
		)
		TABLESPACE pg_default;

		--Establish sequence ownership
		ALTER SEQUENCE user_id_seq2 OWNED BY customer_data.tally;
		--Change table owner to superuser account
		ALTER TABLE public.customer_data
			OWNER to postgres;
		COMMENT ON TABLE public.customer_data
			IS 'Contains main data on JPP users';
	
	--Column constraints
		--syntax: column_name TYPE column_constraint
	 	NOT NULL: Value cant be null
		UNQIUE: Value of column must be unqiue across entire table (doesnt include null (unlike SQL))
		CHECK: Check a condition when inserting or updating data
		REFERENCES: Constrains the value of the column that exists in a column in another table. Use to define foriegn key 
		PRIMARY KEY: NOT NULL + UNQIUE
		
		EG: username VARCHAR (50) UNIQUE NOT NULL
		
	--Table level constraints (appplied to entire table rather than one column)
		UNQIUE(column_list), PRIMARY KEY(column_list), CHECK (condition), REFERENCES
		
	
--Inserting into a table
	INSERT INTO public.customer_data(
						  count, user_id, address, mobile, dob, booleanItem
						  )
						  VALUES (1, '81fcbdf3-ad18-493a-a9bc-6a22512fa13c', 'test', '343444', '2001-07-19', 1);


--Foriegn keys
	--Parent/referenced table, Sales order headers
	CREATE TABLE so_headers (
	   --Serial so automatically increments by 1 for each row, cant be edited unless row is removed
	   id SERIAL PRIMARY KEY,
	   customer_id INTEGER,
	   ship_to VARCHAR (255)
		);
	
	--Child/referencing table, Sales order line items
	CREATE TABLE so_items (
	  item_id INTEGER NOT NULL,   
	  --Foriegn key constraint
	  so_id INTEGER REFERENCES so_headers(id) ON DELETE RESTRICT,
	  product_id INTEGER,
	  qty INTEGER,
	  net_price numeric,
	  PRIMARY KEY (item_id,so_id)
	);
	
	--Each line item of a sales order must belong to a specific sales order (in the so_headers parent table)
	--Each sales order can have one or many line items.
		--So its a one-to-many relationship
		
		--As a result cant insert into so_items without referencing a valid so_id that matches the parent column
		--hence FK ensures the table contains data of sales items that exist
		
	--Parameter after constraint decides what happens when a row in the parent table is deleted.
		--ON DELETE RESTRICT: Doesnt allow the row to be deleted from parent table (so_headers) until all the referenced rows in child table are deleted (so_items)
		--ON DELETE CASCADE: delete all rows in the so_items table that are referenced to the rows that are being deleted in the so_headers table.
		--ON DELETE NO ACTION: DO nothing
		--Can also apply to updates: ON UPDATE RESTRICT, ON UPDATE CASCADE and ON UPDATE NO ACTION.
	
	--Define group of columns as the foriegn key
	FOREIGN KEY (c2, c3) REFERENCES parent_table (p1, p2)
	
--Alter existing tables
	--Syntax: ALTER TABLE [itemName] [action] [itemSubset] [itemSubsetName]  
	--Add foriegn key
		ALTER TABLE child_table 
		ADD CONSTRAINT constraint_name FOREIGN KEY (c1) REFERENCES parent_table (p1);	
	--Edit columns
		--Add column																					 
			ALTER TABLE table_name, can add multiple columns via chaining multiple statements using comments
			ADD COLUMN new_column_name data_type constraint;		
			--Adding a column with a NOT NULL restraint will violate the rule
				--create the data normally -> update values -> set NOT NULL
					ALTER TABLE customers
					ALTER COLUMN contact_name SET NOT NULL;																				 
				--or add column with default value
		--Del column
			ALTER TABLE table_name DROP COLUMN column_name;
		--Rename column, remove COLUMN column_name to rename table				 
			ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name; 	
		--Change default value
			ALTER TABLE table_name ALTER COLUMN column_name [SET DEFAULT value | DROP DEFAULT];
		--Add constraint
			ALTER TABLE table_name ADD CONSTRAINT constraint_name constraint_definition (targetColumn);
																						 
--Select (queries)
	SELECT column_name, columnName2 FROM table_name;
	SELECT [pre_keyword] column_name FROM table_name [condition_keyword] [condition_data] [condition_keyword2] [condition_data2];
	--Can put NOT operator before most condition_keywords to reverse effect
																						 																				 
	--Only use expressions
	SELECT 5 * 3 AS result;
	
	--pre_keywords
		--Ignore rows with duplicate data 
			SELECT DISTINCT column_1 FROM table_name;																					 
			--With 2 columns with look for duplicates based on their combination
			--Keep first row of each group of duplicates
				--DISTINCT ON (column_1) column_alias, column_2																				 
				SELECT DISTINCT ON (column_1) column_alias, column_2 FROM table_name;
																						 
																						 
	--condition_keywords
		--WHERE, combine clause and operators (AND, OR, < (and all variants))
			SELECT last_name, first_name FROM customer WHERE [condition_keyword] 
			
			first_name = 'Jamie' AND last_name = 'Rice';
			first_name IN ('Ann','Anne','Annie');																		 
			--% is the wildcard that matches any string								
			first_name LIKE 'Ann%'
			first_name LIKE 'A%' AND LENGTH(first_name) BETWEEN 3 AND 5						
		--ORDER BY, order column contents
			ORDER BY column_1 ASC, column_2 DESC;		
		--GROUP BY, divide query results into groups
		 --can use a column_list or an expression instead of one column, apply AF (sum(), count()) to get info on group (not applying AF can be used to remove duplicate columns only)
			SELECT column_1, aggregate_function(column_2) FROM tbl_name GROUP BY column_1;
			--Use having clause to sort columns, WHERE acts before GROUP BY but HAVING acts after
			SELECT column_1, aggregate_function (column_2) FROM tbl_name GROUP BY column_1 HAVING condition_;									 
			--GROUPING SETS allows you to define multiple grouping sets in the same query.
			 --EG  for table with 3 columns, query to create a single result set with the aggregates for all grouping sets.
				SELECT c1, c2, aggregate_function(c3) FROM table_name GROUP BY
				 GROUPING SETS ((c1, c2), (c1), (c2), ());
				--EG For table with columns brand, segment, quantity
				SELECT brand, segment, SUM (quantity) FROM sales GROUP BY
				 GROUPING SETS ((brand, segment), (brand), (segment), ());
			--Grouping function, returns 0 (is), 1 (isn't) relative to whether the passed column name is a member of the current grouping set (uses aliases to display the result)
				SELECT GROUPING(brand) grouping_brand, GROUPING(segment) grouping_segement, brand, segment,
				 SUM (quantity) FROM sales GROUP BY
				  GROUPING SETS ((brand, segment), (brand), (segment), ()) ORDER BY brand, segment;
		
				
		
		--LIMIT, reduce number of comlums selected
			--Skip first m rows, then take n rows																			 								
			LIMIT n OFFSET m;
			--Normally order is unpredictable so order how u want first																			 	
			ORDER BY film_id LIMIT 5; 
		--Fetch (SQLite compatible alt to LIMIT)
			syntax
				OFFSET start { ROW | ROWS }
				FETCH { FIRST | NEXT } [ row_count ] { ROW | ROWS } ONLY
			ORDER BY title FETCH FIRST ROW ONLY;
			
			
				
				
																					 
	--Aliases, assign alias to a query result, AS keyword is optional
		SELECT column_name AS alias_name FROM table;																				 
			--Merge results into one column (using expressions)
			SELECT first_name || ' ' || last_name AS full_name FROM customer;		
		SELECT column_list FROM table_name AS alias_name;
			--Shorten statements
				SELECT t.column_name FROM a_very_long_table_name t;			
				--Long statement that queries data from multiple tables that have the same column names																		 
				SELECT t1.column_name, t2.column_name FROM table_name1 t1 INNER JOIN table_name2 t2 ON join_predicate;																		 
			--To reference a table multiple times within a query, EG when self-joining tables
				SELECT colum_list FROM table_name table_alias INNER JOIN table_name ON join_predicate;																			 
	
	
	
	--Joins
		--Combine columnsfrom one (self-join) or more tables based on values of common columns between these tables
		--Generally fk columns from first table and sk columns from the second table
		--Inner join, returns rows in the left table that match with rows from the right table
			SELECT a.id id_a, a.fruit fruit_a, b.id id_b, b.fruit fruit_b
			 FROM basket_a a INNER JOIN basket_b b ON a.fruit = b.fruit;						
		--Outer joins
			--Left join, all rows from left table query with avaliable matching rows right table (Some left rows may get a null match)																				 
				 LEFT JOIN basket_b b ON a.fruit = b.fruit;																		
				--To ignore matching rows (only get rows in the left table)
				WHERE b.id IS NULL;
			--Right join, reversed left join
				RIGHT JOIN basket_b b ON a.fruit = b.fruit;
			--full join, all rows from both left and right table query results, with matching rows where avaliable 	
				FULL JOIN basket_b b ON a.fruit = b.fruit;																		 
			 	--Ignore values that match
			 	WHERE a.id IS NULL OR b.id IS NULL;																			 
			--Could think of joins as a venn diagram, inner = AnB, left =  A, left where B is null = AnB', right = B, full = AuB, full where A or B is null = (AnB)'
		--Cross join, row that consists of all columns in the T1 table followed by all columns in the T2 table.
			SELECT * FROM T1 CROSS JOIN T2;				
			T1: A, B, T2: 1, 2, 3																			 
		--Natural join, implciit join based on same column names, effective for foriegn keys
		 	syntax
				SELECT * FROM T1 NATURAL [INNER, LEFT, RIGHT, *] JOIN T2;		
				--Though dont need to specify join clause as it uses an implicit join clause based on the common column, however may have unexpected results with multiple common columns																	 
				--Where categories is a fk in the products table																		 
				SELECT * FROM products NATURAL JOIN categories;	
				--The result is that columns are sorted around the fk's parent 
																					 
	--Combine results of two select statements
		SELECT column_1, column_2 FROM tbl_name_1 [combine_keyword] [select_statement2]
			--Union statement, requires same number of columns and the same data types within them
			 --removes dupes automatically unless UNION ALL used instead
				
				UNION SELECT column_1, column_2 FROM tbl_name_2; 
			--Intersect statement, returns rows that are the same in both queries  
				INTERSECT SELECT column_list FROM B; 
			--Except operator, returns distinct rows from the first query not in the output of the second query. 
				EXCEPT SELECT column_list FROM B WHERE condition_b;
								
		SELECT first_name, last_name FROM customer WHERE customer_id IN (
		 SELECT customer_id FROM rental WHERE CAST (return_date AS DATE) = '2005-05-27');
		
      
																					 
																						 
																						 
																						 
																							 	
						
																						 
																						 
																						 
																						 
																						 
																						 
																						 
																						 
																						 
																						 
																						 
																						 
																						 
																						 
																						 






	
